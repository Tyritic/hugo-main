---
date : '2025-03-23T20:54:56+08:00'
draft : false
title : 'Redis面试总结'
image : ""
categories : ["Redis"]
tags : [""]
description : "Redis的常见面试题"
math : true
---

## Redis的使用场景

### Redis一般如何使用？

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此 **读写速度非常快** ，常用于 **缓存，消息队列、分布式锁等场景** 。

- **缓存** ：Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载，这对于需要快速响应时间的应用程序非常重要。
- **排行榜** : Redis的有序集合结构非常适合用于实现排行榜和排名系统，可以方便地进行数据排序和排名。
- **分布式锁** : Redis的特性可以用来实现分布式锁，确保多个进程或服务之间的数据操作的原子性和一致性。
- **计数器** ： 由于Redis的原子操作和高性能，它非常适合用于实现计数器和统计数据的存储，如网站访问量统计、点赞数统计等。
- **消息队列**: ：Redis的发布订阅功能使其成为一个轻量级的消息队列，它可以用来实现发布和订阅模式，以便实时处理消息。

## Redis的设计策略

### 如何设计Redis的存储、加载和过期策略？

- **存储策略** ：根据数据的实际形态和操作需求选择合适的 Redis 数据结构。例如，若存储用户信息，其中包含多个字段，可以使用哈希（Hash）结构，将每个字段作为哈希的一个域，方便对用户信息的各个字段进行独立的读写操作。
- **加载策略** ：
  - 根据业务需求，只在需要使用数据时才从 Redis 中加载，而不是在系统启动时就将所有商品数据都加载到内存中，这样可以减少系统启动时间和内存占用。
  - 为了避免加载数据时阻塞主线程，可以采用异步加载的方式。例如，使用线程池或消息队列等技术，在后台线程中进行数据加载操作，主线程可以继续处理其他业务逻辑，提高系统的响应速度和并发处理能力。
- **过期策略** ：
  - 为不同类型的数据设置合理的过期时间。对于一些时效性较强的数据，如短信验证码，通常设置较短的过期时间
  - 采用惰性删除和定期删除相结合的过期策略。惰性删除是在访问键时检查键是否过期，如果过期则删除。定期删除是每隔一段时间随机检查一些键，删除过期的键。合理配置定期删除的时间间隔和检查的键的数量

## Redis的缓存设计

### 缓存雪崩、缓存击穿、缓存穿透是什么，它们的解决方案是什么？

- **现象定义**
  - **缓存雪崩** ：当 **大量缓存数据在同一时间过期（失效）** 时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃
  - **缓存击穿** ：如果缓存中的 **某个热点数据过期** 了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。
  - **缓存穿透** ：当用户访问的数据，**既不在缓存中，也不在数据库中** ，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增。
- **产生原因**
  - **缓存雪崩**
    - 缓存中存储的 key 设置了相同的过期时间，导致大量 key 同时失效。
    - 外部因素（ Redis 服务故障、网络问题等）使得缓存失效。
  - **缓存击穿**
    - 某个热点数据过期
  - **缓存穿透**
    - 客户端恶意请求不存在的 key，或者攻击者利用大量不存在的 key 进行攻击。
    - 程序逻辑中对非法数据缺少过滤，导致频繁请求不存在的数据。
- **解决方案**
  - **缓存雪崩**
    - **均匀设置过期时间** ：如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时， **给这些数据的过期时间加上一个随机数** ，这样就保证数据不会在同一时间过期。
    - **后台更新缓存** ：业务线程不再负责更新缓存，缓存也不设置有效期，而是 **让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新** 。
    - **互斥锁** ：当业务线程在处理用户请求时， **如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存** （从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。实现互斥锁的时候，设置 **超时时间** ，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。
  - **缓存击穿**
    - **互斥锁** ：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
    - **不给热点数据设置过期时间** ：由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间
  - **缓存穿透**
    - **限制非法请求** ：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。
    - **缓存空值或者默认值** ：当线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。
    - **布隆过滤器** ：在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行

### 布隆过滤器的原理

布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，主要用于判断一个元素是否在一个集合中。

#### 特点

- **可能出现误判（假阳性）** ： 当布隆过滤器判断某个元素存在时，可能会有少量误判，但如果判断某个元素不存在，则一定不存在（不会出现假阴性）。
- **内部结构** ：布隆过滤器由一个固定长度的位数组和一组独立的哈希函数组成。

#### 工作原理

- 添加元素：当需要将一个元素加入集合时，依次使用 k 个不同的哈希函数对该元素进行哈希，得到 k 个位置，将位数组中对应的 k 个位置置为 1。
- 判断元素是否存在：当判断一个元素是否在集合中时，同样使用 k 个哈希函数计算出 k 个位置：
  - 如果这 k 个位置中有任意一个位为 0，则该元素一定不在集合中；
  - 如果所有位置都是 1，则认为该元素可能在集合中（此处可能存在哈希碰撞，导致误判）。

### 写操作时数据库与Redis数据缓存的一致性保障