---
date : '2025-03-27T16:03:09+08:00'
draft : false
title : 'Java并发面试总结'
image : ""
categories : ["Java并发编程"]
tags : [""]
description : "Java并发常见面试题"
math : true
---

## synchronized

### synchronized的底层原理

**`synchronized`** 是Java提供的原子性内置锁。当 **`synchronized`** 修饰在方法或代码块上时，会对特定的对象或类加锁，从而确保同一时刻只有一个线程能执行加锁的代码块。

- **synchronized 修饰方法**：会在方法的访问标志中增加一个 **`ACC_SYNCHRONIZED`** 标志。每当一个线程访问该方法时，JVM 会检查方法的访问标志。如果包含 **`ACC_SYNCHRONIZED`** 标志，线程必须先获得该方法对应的对象的监视器锁（即对象锁），然后才能执行该方法，从而保证方法的同步性。
- **synchronized 修饰代码块**：会在代码块的前后插入 **`monitorenter`** 和 **`monitorexit`** 字节码指令。
  - 执行 **`monitorenter`** 指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。
  - 执行 **`monitorexit`** 指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。

从源码的角度上

- 当多个线程进入同步代码块时，首先进入 **`entryList`**
- 有一个线程获取到 **`monitor`** 锁后，就赋值给当前线程，并且计数器+1
- 如果线程调用 **`wait`** 方法，将释放锁，当前线程置为null，计数器-1，同时进入 **`waitSet`** 等待被唤醒，调用 **`notify`** 或者notifyAll之后又会进入 **`entryList`** 竞争锁
- 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null

## AQS

### AQS的底层原理

AQS全称为抽象队列同步器，是Java中的一个抽象类。AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。

AQS核心思想是如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。

AQS底层有几个重要的变量

- **`State`** ：被 **`volatile`** 修饰的int类型的成员变量来表示同步状态
- **CLI队列** ：通过内置的FIFO队列来完成资源获取的排队工作将每条请求共享资源的线程封装成一个节点来实现锁的分配。

调度机制：当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。

## 线程池

### 线程池的创建

#### 在 JDK 里面创建线程池是怎么创建？有哪些方式？

#### 提倡使用静态类提供的工厂方法来创建线程池吗？或者有会有什么问题吗？
