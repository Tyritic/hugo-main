---
date : '2025-05-05T10:31:24+08:00'
draft : false
title : '设计模式基础'
image : ""
categories : ["设计模式"]
tags : ["后端开发"]
description : "设计模式的基础内容"
math : true
---
## 什么是设计模式

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

设计模式的作用

- **帮助我们快速解决常见问题**：设计模式提供了解决特定软件设计问题的通用方法，拿来套上即用，例如单例模式、代理模式、责任链模式等等。
- **提升代码可扩展性**：设计模式通常考虑了软件的扩展性，将不同的功能和功能变化分离开来实现，使得未来添加新功能更加容易。
- **提高代码可重用性**：设计模式本身就是经验的总结，按照设计模式的思路，很多代码封装的很好，便于复用，减少重复工作。
- **提升代码可维护性**：通过使用设计模式，使得代码结构更加清晰，易于理解和维护。

## 设计模式的原则

- **单一职责原则（SRP）**：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
- **开放封闭原则（OCP）**：**软件实体应该对扩展开放，对修改封闭** 。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
- **里氏替换原则（LSP）**：**任何父类可以出现的地方，子类一定可以出现，子类对象应该能够替换掉所有父类对象。** 例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
- **接口隔离原则（ISP）**：**客户端（指调用者或者使用者）不应该被迫依赖它不使用的方法，即一个类对另一个类的依赖应该建立在最小接口上**。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
- **依赖倒置原则（DIP）**：**高层模块不应该依赖低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。**
- **最少知识原则 (Law of Demeter)**：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。一个对象应尽量少地了解其他对象的内部细节。一个对象只应与直接的朋友通信，而不与朋友的朋友通信。直接的朋友指的是那些直接与当前对象进行交互的对象。

## 设计模式的分类

### 创建型模式

用于创建对象的模式，同时隐藏对象创建的逻辑，避免代码中出现大量 new 操作和复杂的创建逻辑。目的是解耦对象的创建和使用

常见模式

- 工厂模式（Factory Pattern）：定义一个创建对象的接口，但由子类决定实例化哪个类。
- 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
- 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。
- 建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- 原型模式（Prototype Pattern）：通过复制现有的实例来创建新的实例。

### 结构型模式

这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。

常见模式

- 适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口。
- 桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- 组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构。
- 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。
- 外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面。
- 享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象。
- 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问

### 行为型模式

这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。

常见模式

- 责任链模式（Chain of Responsibility Pattern）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。
- 命令模式（Command Pattern）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
- 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
- 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
- 中介者模式（Mediator Pattern）：用一个中介对象来封装一系列的对象交互。
- 备忘录模式（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
- 观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 状态模式（State Pattern）：允许一个对象在其内部状态改变时改变它的行为。
- 策略模式（Strategy Pattern）：定义一系列的算法,把它们一个个封装起来, 并且使它们可互相替换。
- 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
- 访问者模式（Visitor Pattern）：为一个对象结构中的各元素提供一个在不改变元素类的前提下定义作用于这些元素的新操作。