---
date : '2024-11-14T19:21:51+08:00'
draft : false
title : 'Java中的继承'
image : ""
categories : ["Java基础"]
tags : ["JavaSE"]
description : "手写笔记转换"
math : true
---

## 继承的定义

**继承**（inheritance）是面向对象中的一个概念。它使得**复用以前的代码非常容易。**

在 Java 语言中**继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法**。

## 继承的优缺点

**优点**：

- **代码复用**：子类可以复用父类的代码，减少重复实现。
- **易于维护**：可以通过修改父类代码来影响所有子类。

**缺点**：

- **紧耦合**：子类依赖于父类的实现，父类的修改可能会影响子类。
- **灵活性差**：继承层次结构可能会变得复杂，不易于调整或扩展。

## 继承的特点

- Java不允许多重继承（一个子类同时继承多个父类）但是支持多层继承，一个类只能继承一个父类（原因参见[博客](https://tyritic.github.io/p/java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BD%86%E6%98%AF%E5%85%81%E8%AE%B8%E5%A4%9A%E5%AE%9E%E7%8E%B0/)）
- `Object`类是所有类中的公共父类
- 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常
- 子类可以继承父类的部分属性和方法

## 继承的语法实现

```java
class 子类名 extends 父类名{}
```



## 子类继承的内容

### 父类的所有属性

子类继承父类的所有的属性（但是被`private`修饰的变量被隐藏无法直接使用）

如果要使用父类的`private`属性可以通过父类的`getter`方法和`setter`方法

### 父类的构造方法不能被继承

**父类的构造方法不能被子类继承**：因为构造方法语法是**与类同名**，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。

### 成员方法（虚方法）

#### 方法传递机制

Java虚拟机从最顶级的父类开始设置**虚方法表**，父类会将**虚方法表**传递给自己的子类，然后在父类的**虚方法表**的基础上添加自己的虚方法从而形成自己的**虚方法表**

虚方法的条件

- 非`static`
- 非`final`
- 非`private`

只有**虚方法表**中的方法会被子类继承

## super关键字

`super`关键字用于指代父类的存储空间

- 指向父类对象；
- 调用父类的方法；
- `super()` 可以调用父类的无参构造方法。

## 继承中成员变量调用规则

成员变量的调用规则满足就近原则

寻找顺序为：方法局部位置——>本类的成员位置——>父类成员位置

逐级向上寻找

使用`this`直接调用本类的变量

使用`super`调用父类的变量

## 继承中成员方法调用规则

### 直接调用

成员方法的调用规则满足就近原则

寻找顺序为：方法局部位置——>本类的成员方法——>父类成员方法

逐级向上寻找

使用`this`直接调用本类的方法

使用`super`调用父类的方法

### 方法重写

子类中重写父类中的方法，保持返回值类型，方法名，参数列表不变，它建立在继承的基础上。

#### 重写条件

- 重写方法的名称、形参列表必须与父类中的一致。
- 子类重写父类方法时，访问权限子类必须大于等于父类(`default`<`protected`<`public`)
- 子类重写父类方法时，返回值类型子类必须小于等于父类
- 只有被添加到虚方法表中的方法才能被重写（静态方法，私有方法，被`final`修饰的方法不能重写）
- 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常

#### 底层实现

子类重写的新方法覆盖从父类继承来的虚方法表中父类的同名方法

#### 示例代码

```java
class E1{
    public void doA(int a){
        System.out.println("这是父类的方法");
    }
}
class E2 extends E1{
    @Override
    public void doA(int a) {
        System.out.println("我重写父类方法，这是子类的方法");
    }
}
```

### 构造方法

- **子类的所有构造方法默认必须调用其父类的构造方法再执行自己的构造方法**：Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。
- **如果子类的构造方法中没有显式地调用父类构造方法，则系统默认调用父类无参数的构造方法**：所有子类的构造方法第一行必须为`super()`
- **任何情况下实例化对象会调用继承链的所有父类构造方法**
- **子类无法继承父类的构造方法但是可以通过`super`关键字来调用**
- **当父类只有有参构造函数时，子类必须显式调用 `super` 并传入合适的参数。**

**示例代码**

```java
// 正确继承演示
class A{
    public String name;
    public A() {//无参构造
    }
    public A (String name){//有参构造
    }
}
class B extends A{
    public B() {//无参构造
       super();
    }
    public B(String name) {//有参构造
      //super();
       super(name);
    }
}
```

## 继承中类的加载顺序

在Java继承中，父子类初始化先后顺序为：

1. 父类中静态成员变量和静态代码块
2. 子类中静态成员变量和静态代码块
3. 父类中普通成员变量和代码块，父类的构造函数
4. 子类中普通成员变量和代码块，子类的构造函数

总的来说，就是**静态>非静态，父类>子类，非构造函数>构造函数**。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。
