---
date : '2024-06-12T20:58:45+08:00'
draft : false
title : '传输层协议'
image : ""
categories : ["计算机网络"]
tags : ["计算机基础"]
description : "手写笔记转换"
math : true
---

## 传输层的作用

**主要职责** ：负责不同主机的进程间通信

**功能**

- **拥塞控制** ：防止**整个网络**因负载过大而崩溃
- **流量控制** ：协调发送速率和接受速率
- **提供端到端服务** ：不同主机之间的进程通信

**常见协议**

- **TCP** ：面向连接的可靠传输服务
- **UDP** ：非面向连接的不可靠传输服务

## 多路复用和多路分解

- **多路分解** ：在接收端，传输层检测报文的字段，识别出接受端的socket，进而将报文段定向并正确交付到对应的socket中
- **多路复用** ：源主机从不同的socket收集数据块，并将数据报封装首部信息，从而生成报文段。然后将报文段交付到网络层

### 无连接的多路复用和多路分解

通过UDP套接字分配特定端口

UDP套接字的格式（目的IP，目的端口号）

### 有连接的多路复用和多路分解

通过TCP套接字分配端口

TCP套接字的格式（源IP，源端口号，目的IP，目的端口号）

## 面向连接的可靠传输—TCP协议

TCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。数据任何时候都可以双向传输。

### TCP的主要特点

- **面向连接** ：双方传输数据之前，必须先建立一条通道
- **可靠传输** ：TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达，通过确认（ACK）、重传机制以及序列号，TCP 能够保证数据在不可靠的 IP 网络上可靠传输。
- **面向字节流** ：虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，
- **差错检测** ：发现差错会重发报文段
- **拥塞控制** ：TCP 通过拥塞避免算法（如慢启动、拥塞避免、快速重传和快速恢复）来防止网络过载，协调整个网络的流量，使得每条TCP连接共享带宽
- **流量控制** ：TCP 通过滑动窗口机制调节发送方的数据发送速率，防止接收方因为处理能力有限而被数据流淹没。

### TCP报文格式

![TCP 头格式](format,png-20230309230534096.png)

报文段 = 首部 + 数据

- **首部** ：最小长度 **20** 字节

  - **源端口号和目的端口号** ：对应用层数据进行多路复用和多路分解

  - **序列号 `seq`** ：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

  - **确认号 `ack`** ：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

  - **控制位**

    - *ACK*：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
    - *RST*：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
    - *SYN*：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
    - *FIN*：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

  - **窗口**：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。

    **校验和**：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。

- **数据**

### TCP粘包，拆包

#### 现象描述

- **粘包** ：在 TCP 传输中，发送方的多个数据包在接收方被合并成一个包接收，导致多条消息数据粘在一起，接收方无法正确区分这些消息的边界。
- **拆包** ：发送方的一个数据包在接收方被分成了多个包接收，导致一条完整的消息被拆成多个部分，接收方无法一次性接收到完整的数据。

#### 出现原因

- **粘包** ：TCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。数据在发送方可能被一次性发送，接收方在读取时可能会将多个消息拼接在一起。
- **拆包** ：由于网络传输中的 MTU（最大传输单元）限制或发送缓冲区大小限制，一个大包被分成了多个小包传输。

#### 解决方案

- **消息定长** ：每个发送的数据包大小固定，不足的部分用空格补充，接受方取数据的时候根据这个长度来读取数据
- **消息末尾增加换行符来表示一条完整的消息** ：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。
- **使用消息头** ：在消息的头部添加一个长度字段，指示消息的长度，接收方根据这个长度来读取相应长度的数据。（UDP的设计方法）

### TCP连接的基本认识

TCP 为每个数据流初始化并维护的某些状态信息（这些信息包括 socket、序列号和窗口大小），称为连接。

建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。

- **Socket**：由 IP 地址和端口号组成，是通信的端点
- **序列号**：用来解决乱序问题，帮助于接收方按顺序重组数据包，并检测丢包情况
- **窗口大小**：用来做流量控制

#### TCP连接的唯一确定

TCP 四元组可以唯一标识一个连接

- 源地址
- 源端口
- 目的地址
- 目的端口

{{<notice tip>}}

TCP 三元组

三元组指的是 IP 地址和端口号的组合，即 `IP 地址 + 端口号 + 协议类型`。例如，`192.168.1.1:8080 (TCP)` 就是一个三元组。在一个机器上，这样的组合唯一标识了一个网络服务或应用程序。

{{</notice>}}

### TCP连接的建立—三次握手

#### 握手过程

![三次握手](1719902940519-03556a12-819b-42b4-b6f7-41b4448d9d99.png)

- 握手前

  - 客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态

- 第一次握手

  - 客户端向服务端发送特殊的TCP报文段（SYN报文段），该报文段被封装到IP数据报中，客户端处于 `SYN-SENT` 状态，表示向服务端发起连接，并告知服务器自己的初始序列号

  - SYN 报文段结构![SYN 报文](format,png-20230309230500953.png)

    - 客户端随机初始化序号（**`client_isn`**），设为x，填入序列号

    - **`SYN`** 字段置为1

    - 报文段不包含数据

      

- 第二次握手

  - 服务端接收到 **`SYN`** 报文段，为TCP连接分配TCP缓存和变量，并向客户端发送允许连接的报文段 **`（SYN + ACK）`** ，服务端处于 `SYN-RCVD` 状态，表示的连接请求被接受了，并通知客户端自己的初始序列号。
  - SYN+ACK 报文段结构![SYN + ACK 报文](format,png-20230309230504118.png)
    - 服务端随机初始化自己的序号（ **`server_isn`** ）设为y，填入序列号
    - 将确认应答号 **`ack`** 置为 **`client_isn + 1`**
    - SYN和ACK字段置为1
    - 不携带数据

​	{{<notice tip>}}

   第二次握手为什么要传回ACK和SYN

- ACK：是第一次握手的确认报文，告知客户端从客户端到服务端的通信是正常的，服务端正确接收到客户端的信息
- SYN：建立并确认从服务端到客户端的通信

​	{{</notice>}}

- 第三次握手
  - 客户端收到服务端报文后，为TCP连接分配缓存和变量，客户端向服务端发送确认连接的报文（ACK报文），客户端处于 ESTABLISHED 状态。服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态
  - ACK报文结构![ACK报文](1719902940762-a8cb1769-ed0d-4f73-aedf-116d918f23e3.png)
    - 将确认应答号 **`ack`** 置为 **`server_isn + 1`**
    - 将 **`ACK`** 字段置为1
    - 报文可以携带数据

#### 三次握手的必要性

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
  - 一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 **旧的SYN报文中的ISN+1** 。
  - 客户端收到后，发现自己期望收到的确认号应该是 **新的SYN报文中的ISN+1** ，于是就会回 RST 报文。
  - 服务端收到 RST 报文后，就会释放连接。
  - 后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。
- 三次握手才可以同步双方的初始序列号![三次握手和四次握手](1713944607932-bc673dc4-6c94-45f5-a731-d583a44feba8.webp)
  - 当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收
  - 那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应
- 三次握手可以避免资源浪费
  - 如果没有第三次握手，**服务端不清楚客户端是否收到了自己回复的** **ACK** **报文** 。如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会 **建立多个冗余的无效链接，造成不必要的资源浪费。**



{{<notice tip>}}

TCP连接为什么不设计成两次握手（面试题）

- 两次握手无法阻止重复历史连接的初始化
  - **在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**。
    - 服务端在收到 SYN 报文后，就进入 **ESTABLISHED** 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 **ESTABLISHED** 状态。
    - 假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 **ESTABLISHED** 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。
    - 服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。
- 两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
- 两次握手无法识别历史连接
  - **如果握手只有两次**，那么接收方应对发送方的请求只能拒绝或者接受，但是**它无法识别当前的请求是旧的请求还是新的请求**。由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。
  - 如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

{{</notice>}}

#### 初始序列号ISN

**作用**

- 为了防止历史报文被下一个相同四元组的连接接收
  - 当客户端和服务端中出现连接中断，若客户端又与服务端建立了与上一个连接相同四元组的连接，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收

**生成过程**

初始序列号 ISN 是以时间戳为基础生成的。

#### 握手丢失

- 第一次握手丢失（客户端发送SYN报文丢失）：客户端触发超时重传机制
  - 服务端：不会进行任何的动作
  - 客户端：发完SYN报文后处于 **SYN_SENT** 状态。由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文（ **重传的 SYN 报文的序列号都是一样的** ），如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。
- 第二次握手丢失（服务端发送SYN+ACK报文丢失）：客户端和服务端均触发超时重传机制
  - 客户端：第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文（第一次握手）**。
  - 服务端：第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文（第二次握手）**。
- 第三次握手丢失（客户端发送的ACK报文丢失）：服务端触发超时重传机制
  - 客户端：发完SYN报文后处于 **ESTABLISHED** 状态
  - 服务端：第三次握手的 ACK 报文是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。



#### TCP半连接

TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。

**半连接队列和全连接队列**

TCP 进入三次握手前，服务端会从 **CLOSED** 状态变为 **LISTEN** 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。

半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接

- 客户端发送 SYN 到服务端，服务端收到之后，便回复 **ACK 和 SYN**，状态由 **LISTEN 变为 SYN_RCVD**，此时这个连接就被推入了 **SYN 队列**，即半连接队列。
- 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。

#### SYN洪泛攻击

**实现原理**

SYN 洪泛 是一种拒绝服务攻击（DoS）。攻击者伪造**不存在的 IP 地址**, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 **SYN** 接收队列（半连接队列），使得服务器不能为正常⽤户服务。

**应对策略**

- **syn cookie**：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- **SYN Proxy 防火墙**：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。