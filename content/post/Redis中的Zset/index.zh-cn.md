---
date : '2025-02-26T19:53:16+08:00'
draft : false
title : 'Redis中的Zset'
image : ""
categories : ["Redis"]
tags : ["后端开发"]
description : "Redis中的排序集合-ZSet"
math : true
---

## ZSet的定义

Redis的ZSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。ZSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。ZSet具备下列特性：可排序元素不重复查询速度快

![ZSet](zset.png)

## 常用命令

- 查看
  - **`ZSCORE key member`** ：返回有序集合key中元素member的分值
  - **`ZCARD key`**  ：返回有序集合key中元素个数
  - **`ZRANGE key start stop [WITHSCORES]`** ：正序获取有序集合key从start下标到stop下标的元素
  - **`ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]`** ：返回有序集合中指定分数区间内的成员，分数由低到高排序。
  - **`ZCOUNT key min max`** ：计算有序集合中指定分数区间的成员数量。
- 加入元素
  - **`ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN`** ：将一个或多个成员元素及其分数值加入到有序集当中
- 删除元素
  - **`ZREM key member [member ...]`** ：移除有序集中的一个或多个成员，不存在的成员将被忽略。

## 底层实现

Redis 中的 **ZSet（有序集合，Sorted Set）** 是一种由 **跳表（Skip List）** 和 **哈希表（Hash Table）** 组成的数据结构。ZSet 结合了集合（Set）的特性和排序功能，能够存储具有唯一性的成员，并根据成员的分数（score）进行排序。

ZSet 的实现由两个核心数据结构组成：

1. **跳表（Skip List）**：用于存储数据的排序和快速查找。
2. **哈希表（Hash Table）**：用于存储成员与其分数的映射，提供快速查找。

### 跳表的实现原理

**跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表**

![跳表原理](1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png)

跳表的查找复杂度就是 $O(logN)$。

跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 **zskiplistLevel 结构体类型的 level 数组** 。

#### 数据结构

- 层：跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”
- 前进指针：每个层都有一个指向表尾的前进指针（`level[i].forward` 属性），用于从表头向表尾方向访问节点。
- 跨度：用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

#### 查找操作

从最高层开始，逐层向下，直到找到目标元素或确定元素不存在。查找效率高，时间复杂度为 O(logn)

#### 插入操作

- 首先从最高层开始查找插入位置
- 随机决定新节点的层数
  - **跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数**。
- 在相应的层中插入节点并更新指针。

### 跳表和B+树的区别

Redis 是内存数据库，**跳表在实现简单性、写入性能、内存访问模式等方面的综合优势**，使其成为更合适的选择。

|      维度      |             跳表优势              |            B+ 树劣势             |
| :------------: | :-------------------------------: | :------------------------------: |
|  **内存访问**  | 符合CPU缓存局部性，指针跳转更高效 |     节点结构复杂，缓存不友好     |
| **实现复杂度** |     代码简洁，无复杂平衡操作      | 节点分裂/合并逻辑复杂，代码量大  |
|  **写入性能**  |     插入/删除仅需调整局部指针     | 插入可能触发递归节点分裂，成本高 |
|  **内存占用**  |       结构紧凑，无内部碎片        |      节点预分配可能浪费内存      |

Redis 选择使用跳表（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。

- 内存结构和访问模式差异

  - **B+ 树的特性**
    - **磁盘友好** ：B+ 树的设计目标是优化磁盘I/O，通过减少树的高度来降低磁盘寻道次数（例如，一个3层的B+树可以管理数百万数据）。
    - **节点填充率高** ：每个节点存储多个键值（Page/Block），适合批量读写。
    - **范围查询高效** ：叶子节点形成有序链表，范围查询（如 `ZRANGE`）性能极佳。
  - **跳表的特性**
    - **内存友好** ：跳表基于链表，通过多级索引加速查询，**内存访问模式更符合CPU缓存局部性**（指针跳跃更少）。
    - **简单灵活** ：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。
    - **概率平衡** ：通过随机层高实现近似平衡，避免了严格的平衡约束（如红黑树的旋转）。

- 实现复杂度

  - **B+ 树的实现复杂度**：

    - **节点分裂与合并** ：插入/删除时可能触发节点分裂或合并，需要复杂的再平衡逻辑。
    - **锁竞争** ：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。

  - **跳表的实现复杂度**：

    - **无再平衡操作** ：插入时只需随机生成层高，删除时直接移除节点并调整指针。

    - **细粒度锁或无锁** ：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。


## 常见应用

### 实现延时队列

![三分恶面渣逆袭：zset实现延时队列](redis-54bbcc36-0b00-4142-a6eb-bf2ef48c2213.png)

- 任务添加到 zset 中，score 为任务的执行时间戳，value 为任务的内容。
- 定期（例如每秒）从 zset 中获取 score 小于当前时间戳的任务，然后执行任务。
- 任务执行后，从 zset 中删除任务。